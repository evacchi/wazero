+++
title = "Appendix: Trampolines"
layout = "single"
+++

Trampolines are used to interface between the Go runtime and the generated
code, in two cases:

- when we need to **enter the generated code** from the Go runtime.
- when we need to **leave the generated code** to invoke a host function (written in Go).

In this section we want to complete the picture of how a Wasm function gets
translated from Wasm to executable code in the optimizing compiler, by
describing how to jump into the execution of the generated code at run-time.

## Entering the Generated Code

Before the compilation of the function starts, a **preamble** is generated.
This is implemented in `machine.CompileEntryPreamble(*ssa.Signature)`.
The procedure first instantiates a `backend.FunctionABI` struct with metadata
about the expected ABI for a function with a given signature, using the
algorithm outlined in [Go's documentation][abi-cc].



	// First, we save executionContextPtrReg into a callee-saved register so that it can be used in epilogue as well.
	// 		mov %executionContextPtrReg, %savedExecutionContextPtr

	// Next, save the current FP, SP and LR into the wazevo.executionContext:
	// Next is to save the original RBP and RSP into the execution context.


	// Then, move the Go-allocated stack pointer to SP:
	// Now set the RSP to the Go-allocated stack pointer.

		// Allocate stack slots for the arguments and return values.


[abi-arm64]: https://tip.golang.org/src/cmd/compile/abi-internal#arm64-architecture
[abi-amd64]: https://tip.golang.org/src/cmd/compile/abi-internal#amd64-architecture
[abi-cc]: https://tip.golang.org/src/cmd/compile/abi-internal#function-call-argument-and-result-passing


## Leaving the Generated Code


In "[How do compiler functions work?][how-do-compiler-functions-work]",
we already outlined how _leaving_ the generated code works with the help of
a function. We will complete here the picture by briefly describing
the code that is generated.

While there are [ongoing efforts to change the status quo][proposal-register-cc],
Go's traditional calling convention differs in a few ways from the standard
calling convention of the `amd64` and `arm64` architecture. [Traditionally][abi-asm],
Go has followed [Plan 9's calling convention][proposal-register-cc], in which
arguments and results are passed **using the stack**.


## Code

- The trampoline to enter the generated function is implemented by the `backend.Machine.CompileEntryPreamble()` method.
- The trampoline to return traps and invoke host functions is generated by `backend.Machine.CompileGoFunctionTrampoline()` method.

You can find arch-specific implementations in `backend/isa/<arch>/abi_go_call.go`.

## Further References

- Go's [internal ASM documentation][abi-asm] is a good starting point to
  understand the calling convention of the Go runtime.
- Raphael Poss's [The Go low-level calling convention on x86-64][go-call-conv-x86]
  is also an excellent reference for `amd64`.
- Go's [internal ABI documentation][abi-internal] complements Go's ASM documentation
  with details on the internal, unstable ABI, known as *ABIInternal*. Notice that,
  however, the relevant bits to interface with ASM code are in the documentation for
  *ABI0* stable interface, i.e., the aforementioned [internal ASM documentation][abi-asm]

[abi-asm]: https://go.dev/doc/asm
[abi-internal]: https://tip.golang.org/src/cmd/compile/abi-internal
[go-call-conv-x86]: https://dr-knz.net/go-calling-convention-x86-64.html
[proposal-register-cc]: https://go.googlesource.com/proposal/+/master/design/40724-register-calling.md#background
[how-do-compiler-functions-work]: ../../how_do_compiler_functions_work/

